<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>利用Boost.Python, 实现C++编写扩展Python模块</title>
        <link rel="stylesheet" href="../highlight/styles/default.css">
        <script src="../highlight/highlight.pack.js"></script>
    </head>
    <body>
        <script>
            hljs.initHighlightingOnLoad();
        </script>
        <center><h3>利用Boost.Python, 实现C++编写扩展Python模块</h3></center>
        <p>
            以下例子都在Arch Linux下编译并测试通过, 如需在其他Linux发行版或是Windows上测试运行, 请自行搭建编译环境和移植Makefile.
        </p>
        <p><b>Hello World</b></p>
        <p>
            按照惯例, 我们从一个简单的hello world示例开始. 首先是hello.cpp:
        </p>
        <pre><code class="cpp">
#include &lt;boost/python/module.hpp&gt;
#include &lt;boost/python/def.hpp&gt;

char const* greet()                 // (1)
{
   return "hello, world";
}

BOOST_PYTHON_MODULE(hello_ext)      // (2)
{
    using namespace boost::python;
    def("greet", greet);            // (3)
}
        </code></pre>
        <p>
            hello.cpp注解: 行(1)是greet函数定义的开始, 行(2)的宏指示要扩展的python模块名为"hello_ext", 行(3)指定将greet函数导出到python, 并且在python中函数名也叫"greet".
        </p>
        <p>
            用C++扩展python模块的方式, 就是将C++代码编译成和BOOST_PYTHON_MODULE指定的输出模块同名的动态库(linux下为.so), 如果需要再在C++的python模块基础上封装一层Python的包装器. Makefile:
		</p>
        <pre><code>
RM = rm -f
CREATE_SO = g++ -shared
CXX = g++
CXXFLAGS = -fPIC -Wall -g -DNDEBUG 
INCLUDES = -I/usr/include/python3.6m 		# (1)
LDFLAGS = -lboost_python3 -lpython3.6m		# (2)
LDPATH =
VPATH = 

SOURCES = $(shell ls *.cpp)
OBJECTS = $(SOURCES:%.cpp=%.o)
DYNAMICLIB = hello_ext.so					# (3)

all: $(DYNAMICLIB)
	@echo "DYNAMICLIB = $(DYNAMICLIB)" 

.PHONY: clean
clean:
	$(RM) $(DYNAMICLIB) $(OBJECTS)

$(OBJECTS): %.o: %.cpp
	$(CXX) -o $@ -c $(CXXFLAGS) $(INCLUDES) $<

$(DYNAMICLIB): $(OBJECTS)
	$(CREATE_SO) -o $(DYNAMICLIB) $(OBJECTS) $(LDFLAGS)
        </code></pre>
        <p>
			Makefile注解: 行(1)指定python-dev的头文件路径, Boost.Python的头文件会依赖pyconfig.h, 如果make报错找不到pyconfig.h, 那么说明需要安装python-dev包(这是Ubuntu下的包名, 其他linux发行版可能包名不同); 行(2)指定编译依赖libboost_python库和libpython库, 具体版本依赖于具体的linux版本和环境, 当前Makefile指定是生成python3的扩展模块; 行(3)指定编译输出的so名, 记住要和hello.cpp中BOOST_PYTHON_MODULE指定的输出模块名一致.
        </p>
		<p>
			顺利编译出hello_ext.so后, 就需要写个python脚本调用并测试hello_ext模块, test_hello.py如下:
		</p>
        <pre><code class="python">
import hello_ext

s = hello_ext.greet()
print(s)
        </code></pre>
		<p>
			<a href="https://github.com/hexu1985/demo/tree/master/boost/python/hello">完整示例项目</a>
		</p>
        <p><b>Exposing Classes</b></p>
        <p>
            下面我们导出一个C++的类到Python. 其中包括默认的构造函数, 一个get成员函数, 一个set成员函数. world.h: 被导出的C++类
        </p>
        <pre><code class="cpp">
#ifndef __world_h
#define __world_h

#include <string>

struct World                                            // (1)
{
    void set(std::string msg) { this->msg = msg; }      // (2)
    std::string greet() { return msg; }                 // (3)
    std::string msg;
};

#endif
        </code></pre>
        <p>
            world.h注解: 行(1)一个普通的C++结构体, 没有显式定义任何构造函数(编译器会自动生成默认构造函数), 行(2)为一个set成员函数, 行(3)一个get成员函数(greet). 我们希望导出的Python类也包含一个默认构造函数, 一个set成员函数和一个get成员函数(greet). 下面看看利用Boost.Python实现的wrapper code, world.cpp:
        </p>
        <pre><code class="cpp">
#include &lt;boost/python.hpp&gt;
#include "world.h"

using namespace boost::python;

BOOST_PYTHON_MODULE(hello)
{
    class_<World>("World")              // (1)
        .def("greet", &World::greet)    // (2)
        .def("set", &World::set)        // (3)
    ;
}
        </code></pre>
        <p>
            world.cpp注解: 行(1)用过class_模板类导出World类, 同时指定Python对应的类名也叫"World", 行(2)导出World类的greet成员函数, Python对应的函数名仍叫"greet", 行(3)导出World类的set成员函数, Python对应的函数名仍叫"set". Makefile就不在赘述, python测试脚本给出, test_world.py:
        </p>
        <pre><code class="python">
import hello

planet = hello.World()
planet.set('howdy')
s = planet.greet()
print(s)
        </code></pre>
		<p>
			<a href="https://github.com/hexu1985/demo/tree/master/boost/python/world1">完整示例项目</a>
		</p>

        <pre><code class="cpp">
        </code></pre>

        <p>
        </p>
        <pre><code class="cpp">
        </code></pre>

        <p>
            <b>参考资料</b>
            <ul>
                <li>
                    <a href="https://www.boost.org/doc/libs/1_67_0/libs/python/doc/html/tutorial/index.html">Boost.Python Tutorial</a>
                </li>
                <li>
                    <a href="https://blog.csdn.net/raby_gyl/article/details/70888387">利用Boost.Python实现Python C/C++混合编程</a>
                </li>
            </ul>
        </p>
    </body>
</html>
